# 4 Year - Theory of Algorithms


## Problem Sheet: Racket Theory of Algorithms
The following exercises are related to the Racket programming language.

### 1. Re-write the following expressions in Racket and evaluate them using a Racket interpreter/compiler.
```
(a) (3 × (5 + (10 ÷ 5)))
(b) (2 + 3 + 4 + 5)
(c) (1 + (5 + (2 + (10 ÷ 3))))
(d) (1 + (5 + (2 + (10 ÷ 3.0))))
(e) (3 + 5) × (10 ÷ 2)
(f) (3 + 5) × (10 ÷ 2) + (1 + (5 + (2 + (10 ÷ 3))))
```

 Racket code
```racket
(a) (* 3 (+ 5 (/ 10 5)))
(b) (+ 2 3 4 5)
(c) (+ 1 (+ 5 (+ 2 (/ 10 3))))
(d) (+ 1 (+ 5 (+ 2 (/ 10 3.0))))
(e) (* (+ 3 5) (/ 10 2))
(f) (+ (* (+ 3 5) (/ 10 2)) (+ 1 (+ 5 (+ 2 (/ 10 3)))))
```

### 2. Define a procedure discount that takes two arguments: an item’s initial price and a percentage discount. It should return the new price:

```
> (discount 10 5)
9.50
> (discount 29.90 50)
14.95
```

Racket code
```racket
#lang racket

(define (discount value disc)
   (- value (/ (* value disc) 100.0)))


(discount 10 5)
(discount 29.90 50)
```
Output
```
9.50
14.95
```

### 3. Define a function grcomdiv that takes two integers and returns their greatest common divisor.
```
> (grcomdiv 10 15)
5>
(grcomdiv 64 30)
2
```
Racket code
```racket
#lang racket

(define (grcomdiv a b)
    (if (< a b)
        (grcomdiv b a)
            (if (= b 0)
                a
                (grcomdiv (modulo a b) b))))


(grcomdiv 10 15)
(grcomdiv 64 30)
```
Output
```
5
2
```

### 4. Write a function called appearances that returns the number of times its first argument appears as a member of its second argument.

### 5. Write a procedure inter that takes two lists as arguments. It should return a list containing every element that appears in both lists, exactly once.

### 6. Write a procedure noatoms that takes a list and returns the number of atoms it contains.

### 7. Here is a Racket procedure that never finishes its job when n is not 0:
```
(define (forever n)
(if (= n 0)
1 
(+ 1(forever n))))
```
- Explain why it doesn’t give any result.

### 8. Write a function called range that takes an integer n and returns a list containing the atoms 1, 2, 3, . . . , n.

### 9. Write a function called reversel that takes a list and returns it reversed.


### 10. If we list all the natural numbers below 10 that are multiples of 3 or 5, we get 3, 5, 6 and 9. The sum of these multiples is 23. Write a procedure to find the sum of all the multiples of 3 or 5 below 1000.

### 11. Write a procedure called flatten that takes as its argument a list, possibly including sublists, but whose ultimate building blocks are atoms. It should return a sentence containing all the atoms of the list, in the order in which they appear in the original:
```
> (flatten '(((a b) c (d e)) (f g) ((((h))) (i j) k)))
(a b c d e f g h i j k)
```

### 12. Each new term in the Fibonacci sequence is generated by adding the previous two
terms. By starting with 1 and 2, the first 10 terms will be:

```
1, 2, 3, 5, 8, 13, 21, 34, 55, 89
```
By considering the terms in the Fibonacci sequence whose values do not exceed four
million, find the sum of the even-valued terms.

### 13. Write a procedure to-binary that takes a decimal interger and converts it into a list of 0’s and 1’s representing the number in binary form. The least ignificant bit should be on the right of the list.

```
> (to-binary 9)
1001
> (to-binary 23)
10111
```
Racket code
```racket
#lang racket

(define (to-binary n)
    (if (= n 0)
    null
    (cons (modulo n 2) (to-binary (/ (- n (modulo n 2)) 2)))))

(to-binary 9)
(to-binary 23)
```
Output
```
1001
10111
```

### 14. Write a function select that takes two elements, a list and a position in the list, and return the element of the list in that position.
```
> (select (list 1 2 3 4 5) 1)
2
```
Racket code
```racket
#lang racket
(define (select l i)
    (if (= i 0)
        (car l)
        (select (cdr l) (- i 1))))

(select (list 1 2 3 4 5) 1)
```
Output
```
2
```

### 15. Write a function perms that takes a list as its only argument, and returns a list containing all permutations of that list.


## Prime numbers

Racket code
```racket
#lang racket

(define (decide-prime p) 
    (print p)
        (define (non-divisible-by n d) ; anothe function, receive two values
            (cond
            ((= d 1) (println " True")) ; The value just can by one or himself
            (else (if(= (remainder n d) 0) 
                (println " False") ; Value remain 0, the value can divide by another numbers
                (non-divisible-by n (- d 1)))))) 
            (if (= p 1)
                (println " True for number 1") ; If prime is equal one
                (non-divisible-by p (- p 1))))

(for ([p (in-range 100)]) ; iterator, in-range will the total number to in the loop
  (decide-prime p)) ; Pass the value to metho to the top
```
Output for 10 Numbers
```
0" False"
1" True for number 1"
2" True"
3" True"
4" False"
5" True"
6" False"
7" True"
8" False"
9" False"
```

### References: 
- https://rosettacode.org/wiki/Category:Programming_Tasks
- https://ianmcloughlin.github.io/theoryofalgorithms
- https://stackoverflow.com/questions/3345626/finding-a-prime-number-in-scheme-using-natural-recursion
- https://beautifulracket.com/explainer/loops.html
- https://docs.racket-lang.org/guide/for.html

# Author

### Alexander Souza
- G00317835@gmit.ie
- alexpt2000@gmail.com
- https://github.com/alexpt2000gmit
- https://github.com/alexpt2000
- www.linkedin.com/in/alexander-souza-3a841539/